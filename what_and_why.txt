code :
from setuptools import setup, find_packages

setup(
    name="myproject",
    version="0.1",
    packages=find_packages(),  # Automatically include all packages here
    install_requires=[
        "numpy",
        "pandas",
    ]
)


Q. Why use setup.py when requirements.txt se kaam ho skta hai in another system?

ans: Yeh poora project ek Python package bana deta hai, toh project ko install karne par:
Directories, modules, scripts sab sahi tareeke se site-packages mein jaate hain.
Meta info store hoti hai (author, version, etc)
Optional: dependencies bhi yahan declare ho sakti hain using (install_requires), 
toh requirements.txt ki zarurat nahi bhi pad sakti.
Automation/CI/CD, dockerization, ya deployment mein setup.py required hota hai 
taaki Python-style installable/reusable package bana paye aur 
sab kuch sahi tareeke se install ho.



Q. Connection between "-e ." in requirements.txt and setup.py file? 

ans: "-e ." tabhi kaam karta hai jab project mein setup.py (ya pyproject.toml) ho, 
kyunki woh batata hai project ko package kaise karna hai.
Agar setup.py nahi hai, to -e . wala command kaam nahi karega.
"-e ." wo shortcut hai jo setup.py ko use karke project code installable 
& editable banaata hai.
Jab "-e ." use karte hain, pip setup.py/pyproject.toml se instructions leke project ko 
install kar leta hai.
Faida: Apne hi code ko as a "local library" import kar sakte ho, 
bina install/reinstall ki tension ke.
NOTE : "- e." ---> "Editable install" i.e. poore project directory ko install kar lo
"editable" mode mein.



Q. What does find_packages() do in setup.py?

ans: find_packages() Python setuptools ka ek funcn. hota hai jo setup.py mein use kiya jaata hai, aur iska kaam hota hai:
project directory mein jitne bhi Python packages (folders jinmein __init__.py hota hai) hain, 
un sab ko automatically dhoondhna aur unko setup() function ko dena taake wo sari sub-packages install ho jaayein.
find_packages() automatically:
src             - package
components      - subpackage
pipeline        - subpackage 

teeno ko detect karke setup.py ko de deta hai, taake teeno install ho jaayein.
NOTE: its only possible coz teeno mein __init__.py hota hai.

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------


Q. Logging?

ans: Logging ka matlab hai apne code ka kaam, errors, results ya progress ko systematically file/console pe record karna.
Isse tu track kar sakta hai ki code kab, kya kar raha hai, kaun se values aa rahi hain, kahin koi problem hui toh 
kaunse step pe hui. ML/MLOps mein logging important hai—code production mein jaata hai, automate hota hai, 
toh errors ka pata logs se hi chalta hai.
Log levels hote hain: DEBUG, INFO, WARNING, ERROR, CRITICAL—importance ke hisaab se.



Q. Exception?

ans: Exception ka matlab hai koi error ya unexpected situation (jaise file missing, data galat, divide by zero) 
jo code chalte waqt aayi. Exceptions handle karna zaroori hai, warna code crash ho jaata hai.
ML/MLOps mein: data loading, model training, file I/O, deployment—kahin bhi exceptions aa sakte hain, 
inko properly handle karna hota hai taake code survive kare na ke crash ho aur pipeline ruk na jaaye.
Python mein Exceptions k liye try-except block use karte hain.



Q. CustomException?

ans: Custom exception seedhe matlab: tu apne Python project mein apni khud ki error/exception bana sakta hai—
jo teri situation ya business logic ko clearly represent kare.
Bas Python ki Exception class ko inherit kar ke ek nayi class banani hoti hai.
Jab built-in Python errors (jaise ValueError, FileNotFoundError vs) teri specific error ko clearly explain nahi karte 
jaise MLOps ya data pipeline mein (data format galat hai ya model training input corrupt hai), 
toh tu apni exception raise kar sakta hai.
Custom exception = apni specific galtiyon/error cases ko clearly handle aur explain karne ka tareeka.



Q. sys module and CustomException handling?

ans: sys module - Python ka built-in module hai jo interpreter aur system se jude hua kaam karta hai.
Iska ek important use hota hai program exit ya error handling ke context mein — 
jaise sys.exit() se program graceful exit karwana, ya sys.exc_info() se current exception ki detail lena.

CustomException tera apna banaya hua error class hota hai, jo custom error conditions ko represent karta hai.
Tu ise raise karta hai jab koi specific problem aaye, aur try-except mein catch karta hai.

Ab Jab tu koi CustomException raise karta hai, aur tu chahta hai ki is exception ke baare mein detailed info 
leke apni script ko handle ya exit kare, to sys module use hota hai. for eg:

              def error_message_detail(error,error_detail:sys):
                    _,_,exc_tb=error_detail.exc_info()

Overall CustomException se hum apni specific errors define kar lete hain and sys.exc_info() se un exceptions ke 
baare mein low-level info le sakte hai, ya sys.exit() program ko exit kar sakte hai jab error critical ho.

Ye dono i.e. customexception & sys milke robust error handling aur graceful termination provide karte hain, 
jo especially MLOps pipelines mein important hota hai.


---------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------

Q. 2 type of methods to initialize attributes when creating a Class?

ans: Jab apni class banate hain Python mein, do common tareeke hote hain properties (attributes) initialize karne ke:

(a). __init__ method define karna;
Yeh ek special method hota hai jo class ka object banate waqt call hota hai.
Iske andar hum manually variables initialize karte hain, for example;

class Person:                                             
    def __init__(self, name, age):
        self.name = name
        self.age = age

Agar attributes ke sath koi logic, transformation, calculation, ya function lagana hai jab object banta hai 
(jaise input modify karna, validation, extra processing), toh phir __init__ method define karna better hai.

class Person:
    def __init__(self, name, dob):              # Inputs - name, dob i.e. __init__ ke params  
        self.name = name                        # Attributes - self.name, self.age
        self.age = calculate_age(dob)           # Logic input par lag raha hai aur uska result self.age naam 
                                                ke attribute mein store ho raha hai 


(b). @dataclass decorator use karna;
@dataclass automatically:
__init__ method banata hai,
__repr__ (print karne ke liye),
__eq__ (comparison ke liye), and aur aur bhi kuch magic methods define karta hai. Code example;

from dataclasses import dataclass

@dataclass
class Person:
    name: str
    age: int

Agar sirf attributes ko data holder (values store karni hain, koi logic nahin lagani)—toh @dataclass decorator use karo. 
Isme automatic __init__, __repr__, etc. ban jaata hai, aur tu sirf fields (attributes) define karta hai.



__init__ se explicitly control milta hai ki jab object bane, kaunse variables hon, unka initialization kaise ho.
@dataclass se boilerplate code kam ho jaata hai, simple aur readable class ban jaati hai bina manually __init__ likhne ke.

NOTE: @dataclass ke andar bhi agar tumhe kuch custom initialization karna ho toh __post_init__ method 
define kar sakte ho, jo __init__ ke baad automatically call hota hai.


                                    Kab kya use karna chahiye — simple guide:
------------------------------------------------------------------------------------------------------------------------
Situation / Use Case                          Use Kya Karna Hai?                                  Kyu?
------------------------------------------------------------------------------------------------------------------------
Sirf simple classes jisme bas data                @dataclass                     Boht kam code likhna padta hai, __init__, 
store karna hai (eg. naam, age,etc)                                                 __repr__ automatic ban jaata hai


Boht complex initialization ya control 
chahiye (jaise attributes ko differently        Apna custom __init__ likho         Full control milta hai, dataclass 
process karna, multiple inputs handle karna)                                       se zyada flexible hai


-------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
